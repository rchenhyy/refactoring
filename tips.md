* 实例之所以可以拯救我于太虚之中，是因为它让我看见事情在真正进行。
* 不论用户提出什么方案，你唯一能够获得的保证就是他们一定会在六个月之内再次修改它。
* 这个程序也许还没坏掉，但它造成了伤害。

```
如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性。
```

* 你必须让测试有能力自我检验，否则就得耗费大把时间来回对比。
* 好的测试是重构的根本。

```
重构前，先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力。
```

```
重构技术就是以微小的步伐修改程序。如果你犯下错误，很容易便可发现它。
```

```
任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。
```

* 代码应该表现自己的目的，这一点非常重要。
* 绝大多数情况下，函数应该放在它所使用的数据的所属对象内。
* 临时变量往往引发问题，它们会导致大量参数被传来传去，而其实完全没有这种必要。
* 重构时最好小步前进，如此一来犯错的几率最小。
* 重构时你不必担心这些（性能问题），优化时你才需要担心它们，但那时候你已处于一个比较有利的位置，有更多选择可以完成有效优化。
* 最好不要在另一个对象的属性基础上运用switch语句。如果不得不使用，也应该在对象自己的数据上使用，而不是在别人的数据上使用。

```
重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
```

```
重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。
```

* 性能优化往往使代码较难理解，但为了得到所需的性能你不得不那么做。
* 无论何时，你都应该清楚自己戴的是哪一顶帽子（两顶帽子：1-添加功能 2-重构）。
* 代码结构的流失是累积性的。经常性的重构可以帮助代码维持自己该有的形态。
* 消除了重复代码，你就可以确定所有事物和行为在代码中只表述一次，真正是优秀设计的根本。
* 你得及时填补"想要它做什么"和"告诉它做什么"之间的缝隙。这种编程模式的核心就是"准确说出我所要的"。
* 我是个很懒惰的程序员，我的懒惰表现形式之一就是：总是记不住自己写过的代码。
* 擦掉窗户上的污垢，使你看得更远。
* "我不是个伟大的程序员，我只是个有着一些优秀习惯的好程序员"
* 良好设计是维持软件开发速度的根本。

```
事不过三，三则重构
```

* 无论何时，只要我想理解代码所做的事，我就会问自己：是否能对这段代码进行重构，使我能更快地理解它。
* 显然代码还不够清晰——没有清晰到让你能一眼看出bug。
* 要让开发者设身处地为那些不熟悉自己所作所为的人着想，实在太困难了。
* 我不必想象代码应该是什么样，我可以"看见"它是什么样。
* 我会和某个团队进行设计复审，而和单个复审者进行代码复审。
* 如果我纯粹只是为今天工作，明天我将完全无法工作。
* 大量研究结果显示，技术复审是减少错误、提高开发速度的一条重要途径。
* 很多经理嘴巴上说自己"质量驱动"，其实更多是"进度驱动"。
* 重构是理解软件的最快方式。
* 并非我认为对象十全十美、没有局限性——我最反对这种盲目态度，而是尽管我知道它的好处，但确实不知道其局限性在哪儿。
* 一直对重构带来困扰的一件事就是：许多重构手法的确会修改接口。请尽量这么做：让旧接口调用新接口。
* 发布接口很有用，但也有代价。所以除非真有必要，不要发布接口。过度强调代码所有权的团队常常会犯这种错误。

```
不要过早发布接口。请修改你的代码所有权政策，使重构更顺畅。
```

* 我总是喜欢为整个包（package）定义一个异常基类（就像java.sql的SQLException），并确保所有public函数只在自己的throws子句中声明这个异常。
* 我们很难（但还是有可能）将不考虑安全性需求时构造起来的系统重构为具备良好安全性的系统。
* 考虑候选设计方案时，我会问自己：将某个设计重构为另一个设计的难度有多大？如果看上去很简单，我就不必太担心选择是否得当，于是我就会选最简单的设计，哪怕它不能覆盖所有潜在需求也没关系。
* 重写（而非重构）的一个清楚讯号就是——现有代码根本不能正常运作。
* 把债务管理好是很重要的，你应该随时通过重构来偿还一部分债务。
* 如果最后你没有足够时间，通常就表示你其实早该进行重构。
* 重构改变了预先设计的角色。如果没有重构，你就必须保证预先做出的设计正确无误，这个压力太大了。
* 就算幸运地走在预先设想的方向上，你也必须理解如何修改设计。
* 哪怕你完全了解系统，也请实际度量它的性能，不要臆测。臆测会让你学到一些东西，但十有八九你是错的。
* 虽然重构可能使软件运行更慢，但它也使软件的性能优化更容易。
* 除了对性能有严格要求的实时系统，其他任何情况下"编写快速软件"的秘密就是：首先写出可调的软件，然后调整它以求获得足够速度。
* 性能改善一旦被分散到程序各角落，每次改善都只不过是从对程序行为的一个狭隘视角出发而已。
* 关于性能，一件很有趣的事情是：如果你对大多数程序进行分析，就会发现它把大半时间都耗费在一小半代码身上。
* 我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。
* 关键不在于函数的长度，而在于函数函数"做什么"和"如何做"之间的语义距离。
* 如果你手上没有所需的东西，总可以叫另一个对象给你。
* 这两种情况下（"一个类受多种变化的影响/发散式变化" & "一种变化一起多个类的改动/霰弹式修改"）你都会希望整理代码，使"外界变化"与"需要修改的类"趋于一一对应。
* 对象技术的全部要点在于：这是一种"将数据和对数据的操作行为包装在一起"的技术。
* 无数次经验里，我们看到某个函数为了计算某个值，从另一个对象那儿调用几乎半打的取值函数。
* 最根本的原则是：将总是一起变化的东西放在一块儿。
* 这些总是绑在一起出现的数据真应该拥有属于他们自己的对象。
* 得到新对象后，你就可以着手寻找Feature Envy，这可以帮你指出能够移至心累中的种种程序行为。不必太久，所有的类都将在它们的小小社会中充分发挥价值。
* 大多数时候，一看到switch语句，你就应该考虑以多态来替换它。
* 如果一个类的所得不值其身价，他就应该消失。
* 如果函数名称带有多余的抽象意味，应该对它实施Rename Method，让它现实一些。
* 如果你发现这样的函数或类（其唯一调用方是测试用例），请把它们连同其测试用例一并删掉。
* 有时你会看到这样的对象：其内某个实例变量仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。
* 采用这种方式（过长的对象消息链），意味着客户代码将与查找过程中的导航结构紧密耦合。
* 封装往往伴随委托。人们可能过度运用委托。你也许会看到某个类接口有一半的函数都委托给其他类，这就是过度运用。
* 有时你会看到两个类过于亲密，话费太多时间去研究彼此的private成分。如果这发生在两个人之间，我们不必做卫道士；但对于类，我们希望它们严守清规。
* 继承往往造成过度亲密，因为子类对超类的了解总是超过后者的主观愿望。
* 麻烦的是库往往构造得不够好，而且往往不可能让我们修改其中的类使他完成我们希望完成的工作。
* 它们拥有一些字段，以及用于访问这些字段的函数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过分琐碎地操控着。若要让他们想成熟的对象那样参与整个系统的工作，它们就必须承担一定责任。
* 如果子类复用了超类的行为（实现），却又不愿意支持超类的接口，Refused Bequest的坏味道就会变得浓烈。
* 常常会有这样的情况：你看到一段代码有着长长的注释，然后发现，这些注释之所以存在乃是因为代码很糟糕。

```
当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。
```
